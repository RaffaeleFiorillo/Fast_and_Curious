class Car:
    def __init__(self):
        self.y_values = [20, 130, 240]
        self.image = self.get_car_image()
        self.fire_image = None
        self.fire_image_time = 0
        self.last_fire = False
        self.speed = 7
        self.x = 290
        self.y = 130
        self.damage_period = 0.0
        self.hit_box = pygame.mask.from_surface(self.image.convert_alpha())
        self.keep_moving = False
        self.destination = 1
        self.direction = None
        self.rect = (self.x, self.y, self.image.get_size()[0], self.image.get_size()[1])
        self.vision_coo = [[self.x + 150, self.y - 90], [self.x + 150, self.y + 27], [self.x + 150, self.y + 130],
                           [self.x + 70, self.y - 90], [self.x + 70, self.y + 130]]
        self.seen_values = []
        self.po = 0

    def activate_fire(self, fire_type):
        if self.last_fire != fire_type:
            self.last_fire = fire_type
            self.fire_image_time = 0
        if self.fire_image_time < 1:
            self.fire_image_time += 1
        if fire_type:
            f.play(fire_sound)
            self.fire_image = pygame.image.load("images/cars/car effects/nitro/blue.png").convert_alpha()
        else:
            self.fire_image = pygame.image.load("images/cars/car effects/nitro/red.png").convert_alpha()

    @staticmethod
    def get_car_image():
        try:
            file = open("saves/active_user.txt", "r")
            level = file.readline().split(" ")[3]
            file.close()
        except IndexError:
            level = 21
        return pygame.image.load(f"images/cars/{level}.png").convert_alpha()

    def obstacle_collision(self, l_obstacles):
        for obst in l_obstacles:
            if self.hit_box.overlap(obst.hit_box, (self.x - obst.x + obst.adjust, self.y - obst.y + obst.adjust)):
                f.play(hit_sound)
                return True
        return False

    def vision(self, screen):
        self.seen_values = []
        for i in self.vision_coo:
            self.seen_values.append(f.see(screen, i))

    def parts_collision(self, l_parts):
        value = 0
        new_parts = []
        for part in l_parts:
            if part.x + 44 >= self.rect[0] and part.x <= self.rect[0] + self.rect[2]:
                if part.y + 24 >= self.rect[1] and part.y <= self.rect[1] + self.rect[3]:
                    value += part.value
                    f.play(part_sound)
                    continue
                else:
                    new_parts.append(part)
            else:
                new_parts.append(part)
        return new_parts, value

    def draw(self, screen):
        screen.blit(self.image, (self.x, self.y))
        if self.fire_image_time and self.x < 350:
            screen.blit(self.fire_image, (self.x - 40, self.y + 15))
            self.fire_image_time = 0
        # pygame.draw.rect(screen, (255, 255, 0), self.rect, 5)
        for i in self.vision_coo:
            pygame.draw.circle(screen, (255, 242, 0), i, 2, 1)

    def movement(self, event):
        movements = {None: 0, "UP": -self.speed, "DWN": self.speed}
        self.y += movements[event]
        if self.destination == 1:
            if self.direction == "UP":
                self.destination = 2
            elif self.direction == "DWN":
                self.destination = 0
        elif self.destination == 2:
            if self.direction == "UP":
                self.destination = 2
            elif self.direction == "DWN":
                self.destination = 1
        elif self.destination == 0:
            if self.direction == "UP":
                self.destination = 1
            elif self.direction == "DWN":
                self.destination = 0
        self.keep_moving = True
        if self.y > self.y_values[2]:
            self.y = self.y_values[2]
        elif self.y_values[0] > self.y:
            self.y = self.y_values[0]
        self.vision_coo = [[self.x + 150, self.y - 90], [self.x + 150, self.y + 27], [self.x + 150, self.y + 130],
                           [self.x + 70, self.y - 90], [self.x + 70, self.y + 130]]
        self.rect = (self.x, self.y, self.image.get_size()[0], self.image.get_size()[1])

    def continue_mov(self):
        if self.keep_moving:
            self.movement(self.direction)
        if self.y in self.y_values:
            self.keep_moving = False